#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const readline = require('readline');

// ============================================================================
// Constants
// ============================================================================

const CONFIG_FILE = 'mkprompt.config.json';
const OUTPUT_DIR = 'mkprompt';
const VARIABLE_REGEX = /<\?([^?]+)\?>/g;

const DEFAULT_CONFIG = {
  prompts_path: './prompts',
  first_comment: '/* Prompt Generated by mkprompt */',
  last_comment: '/* End of Prompt */'
};

// ============================================================================
// ANSI Colors
// ============================================================================

const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  red: '\x1b[31m'
};

const log = {
  info: (msg) => console.log(`${colors.cyan}â„¹${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}âœ“${colors.reset} ${msg}`),
  warn: (msg) => console.log(`${colors.yellow}âš ${colors.reset} ${msg}`),
  error: (msg) => console.log(`${colors.red}âœ—${colors.reset} ${msg}`),
  prompt: (msg) => process.stdout.write(`${colors.magenta}?${colors.reset} ${msg}`),
  title: (msg) => console.log(`\n${colors.bright}${colors.blue}${msg}${colors.reset}\n`)
};

// ============================================================================
// Readline Interface
// ============================================================================

function createReadlineInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
}

function askQuestion(rl, question) {
  return new Promise((resolve) => {
    rl.question(`${colors.magenta}?${colors.reset} ${question}`, (answer) => {
      resolve(answer);
    });
  });
}

// ============================================================================
// Config Management
// ============================================================================

function loadConfig() {
  const configPath = path.join(process.cwd(), CONFIG_FILE);
  
  if (fs.existsSync(configPath)) {
    try {
      const content = fs.readFileSync(configPath, 'utf8');
      return JSON.parse(content);
    } catch (error) {
      log.error(`Error reading config file: ${error.message}`);
      return DEFAULT_CONFIG;
    }
  }
  
  return null;
}

function createConfig() {
  const configPath = path.join(process.cwd(), CONFIG_FILE);
  const outputPath = path.join(process.cwd(), OUTPUT_DIR);
  const promptsPath = path.join(process.cwd(), 'prompts');
  
  // Create config file
  fs.writeFileSync(configPath, JSON.stringify(DEFAULT_CONFIG, null, 2));
  log.success(`Created ${CONFIG_FILE}`);
  
  // Create output directory
  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath, { recursive: true });
    log.success(`Created ${OUTPUT_DIR}/ directory`);
  }
  
  // Create prompts directory
  if (!fs.existsSync(promptsPath)) {
    fs.mkdirSync(promptsPath, { recursive: true });
    log.success(`Created prompts/ directory`);
    
    // Create example prompt
    const examplePrompt = `You are a helpful assistant specialized in <?specialty?>.

The user's name is <?user_name?> and they are working on a project called <?project_name?>.

Please help them with the following task:
<?task_description?>

Requirements:
- Language: <?programming_language?>
- Framework: <?framework?>

Additional context:
<?additional_context?>
`;
    
    fs.writeFileSync(path.join(promptsPath, 'example.txt'), examplePrompt);
    log.success('Created example prompt: prompts/example.txt');
  }
  
  // Update .gitignore
  updateGitignore();
  
  return DEFAULT_CONFIG;
}

function updateGitignore() {
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  const entriesToAdd = [OUTPUT_DIR + '/'];
  
  let content = '';
  if (fs.existsSync(gitignorePath)) {
    content = fs.readFileSync(gitignorePath, 'utf8');
  }
  
  const lines = content.split('\n').map(l => l.trim());
  const toAdd = entriesToAdd.filter(entry => !lines.includes(entry));
  
  if (toAdd.length > 0) {
    const newContent = content.trim() + '\n\n# mkprompt output\n' + toAdd.join('\n') + '\n';
    fs.writeFileSync(gitignorePath, newContent);
    log.success(`Updated .gitignore with ${OUTPUT_DIR}/`);
  }
}

// ============================================================================
// Prompt Management
// ============================================================================

function getPromptFiles(promptsPath) {
  const fullPath = path.resolve(process.cwd(), promptsPath);
  
  if (!fs.existsSync(fullPath)) {
    return [];
  }
  
  return fs.readdirSync(fullPath)
    .filter(file => {
      const filePath = path.join(fullPath, file);
      const stat = fs.statSync(filePath);
      return stat.isFile() && !file.startsWith('.');
    })
    .sort();
}

function extractVariables(content) {
  const variables = [];
  const seen = new Set();
  let match;
  
  while ((match = VARIABLE_REGEX.exec(content)) !== null) {
    const varName = match[1].trim();
    if (!seen.has(varName)) {
      seen.add(varName);
      variables.push(varName);
    }
  }
  
  return variables;
}

function replaceVariables(content, values) {
  let result = content;
  
  for (const [varName, value] of Object.entries(values)) {
    const regex = new RegExp(`<\\?${escapeRegex(varName)}\\?>`, 'g');
    result = result.replace(regex, value);
  }
  
  return result;
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function formatDate() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  
  return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
}

function getOutputFilename(originalName) {
  const ext = path.extname(originalName);
  const baseName = path.basename(originalName, ext);
  const date = formatDate();
  
  return `${baseName}_${date}${ext || '.md'}`;
}

// ============================================================================
// Main Flow
// ============================================================================

async function selectPrompt(rl, prompts) {
  log.title('ðŸ“ Available Prompts');
  
  prompts.forEach((prompt, index) => {
    console.log(`  ${colors.cyan}${index + 1}${colors.reset}) ${prompt}`);
  });
  
  console.log();
  
  while (true) {
    const answer = await askQuestion(rl, `Select a prompt (1-${prompts.length}): `);
    const index = parseInt(answer, 10) - 1;
    
    if (index >= 0 && index < prompts.length) {
      return prompts[index];
    }
    
    log.error(`Invalid selection. Please enter a number between 1 and ${prompts.length}`);
  }
}

async function fillVariables(rl, variables) {
  log.title('ðŸ“‹ Fill in the variables');
  
  const values = {};
  
  for (const varName of variables) {
    const displayName = varName.replace(/_/g, ' ');
    const answer = await askQuestion(rl, `${colors.yellow}${displayName}${colors.reset}: `);
    values[varName] = answer;
  }
  
  return values;
}

async function main() {
  const args = process.argv.slice(2);
  
  // Handle help command
  if (args.includes('--help') || args.includes('-h') || args.includes('help')) {
    showHelp();
    return;
  }
  
  // Handle config command
  if (args.includes('config')) {
    log.title('âš™ï¸  Creating mkprompt configuration');
    createConfig();
    log.info('\nEdit prompts/ directory to add your prompt templates.');
    log.info('Use <?variable_name?> syntax for dynamic variables.');
    return;
  }
  
  // Handle version command
  if (args.includes('--version') || args.includes('-v')) {
    const pkg = require('../package.json');
    console.log(`mkprompt v${pkg.version}`);
    return;
  }
  
  // Load or create config
  let config = loadConfig();
  
  if (!config) {
    log.title('ðŸš€ Welcome to mkprompt!');
    log.info('No configuration found. Creating default config...\n');
    config = createConfig();
    console.log();
  }
  
  // Ensure output directory exists
  const outputDir = path.join(process.cwd(), OUTPUT_DIR);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Get available prompts
  const prompts = getPromptFiles(config.prompts_path);
  
  if (prompts.length === 0) {
    log.error(`No prompts found in ${config.prompts_path}/`);
    log.info('Add prompt template files to the prompts directory.');
    log.info('Use <?variable_name?> syntax for dynamic variables.');
    return;
  }
  
  const rl = createReadlineInterface();
  
  try {
    // Select prompt
    const selectedPrompt = await selectPrompt(rl, prompts);
    const promptPath = path.join(process.cwd(), config.prompts_path, selectedPrompt);
    
    log.success(`Selected: ${selectedPrompt}\n`);
    
    // Read prompt content
    const content = fs.readFileSync(promptPath, 'utf8');
    
    // Extract variables
    const variables = extractVariables(content);
    
    let finalContent;
    
    if (variables.length === 0) {
      log.info('No variables found in this prompt.');
      finalContent = content;
    } else {
      log.info(`Found ${variables.length} variable(s): ${variables.map(v => colors.yellow + v + colors.reset).join(', ')}\n`);
      
      // Fill variables
      const values = await fillVariables(rl, variables);
      
      // Replace variables
      finalContent = replaceVariables(content, values);
    }
    
    // Build output
    const outputContent = [
      config.first_comment,
      '',
      finalContent,
      '',
      config.last_comment
    ].join('\n');
    
    // Generate output filename
    const outputFilename = getOutputFilename(selectedPrompt);
    const outputPath = path.join(outputDir, outputFilename);
    
    // Write output
    fs.writeFileSync(outputPath, outputContent);
    
    log.title('âœ¨ Prompt generated successfully!');
    log.success(`Output: ${OUTPUT_DIR}/${outputFilename}`);
    
    // Show preview
    console.log(`\n${colors.dim}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${colors.reset}`);
    console.log(`${colors.dim}Preview:${colors.reset}\n`);
    
    const previewLines = finalContent.split('\n').slice(0, 10);
    previewLines.forEach(line => {
      console.log(`  ${colors.dim}${line}${colors.reset}`);
    });
    
    if (finalContent.split('\n').length > 10) {
      console.log(`  ${colors.dim}...${colors.reset}`);
    }
    
    console.log(`\n${colors.dim}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${colors.reset}\n`);
    
  } finally {
    rl.close();
  }
}

function showHelp() {
  console.log(`
${colors.bright}${colors.blue}mkprompt${colors.reset} - Dynamic Prompt Generator

${colors.bright}USAGE${colors.reset}
  mkprompt              Generate a prompt from templates
  mkprompt config       Create configuration file and directories
  mkprompt help         Show this help message

${colors.bright}OPTIONS${colors.reset}
  -h, --help            Show help
  -v, --version         Show version

${colors.bright}CONFIGURATION${colors.reset}
  The mkprompt.config.json file supports:

  ${colors.cyan}prompts_path${colors.reset}    Directory containing prompt templates (default: ./prompts)
  ${colors.cyan}first_comment${colors.reset}   Comment added at the beginning of output
  ${colors.cyan}last_comment${colors.reset}    Comment added at the end of output

${colors.bright}VARIABLE SYNTAX${colors.reset}
  Use ${colors.yellow}<?variable_name?>${colors.reset} in your prompts for dynamic values.

${colors.bright}EXAMPLE PROMPT${colors.reset}
  ${colors.dim}You are an expert in <?technology?>.
  Help <?user_name?> with their project about <?topic?>.${colors.reset}

${colors.bright}OUTPUT${colors.reset}
  Generated prompts are saved to the mkprompt/ directory
  with the format: promptname_YYYY-MM-DD_HH-MM-SS.ext

${colors.bright}MORE INFO${colors.reset}
  https://github.com/yourusername/mkprompt
`);
}

// Run
main().catch(error => {
  log.error(`Unexpected error: ${error.message}`);
  process.exit(1);
});
